"""
Sanitization utilities for user-generated content (SEC-3-INPUT).

This module provides comprehensive sanitization for:
- HTML/XSS payloads
- Markdown content
- URLs (GitHub, external links)
- Code snippets
- SQL injection attempts (via parameterized queries)

Security Principles:
- Allowlist approach (only allow known-safe tags/attributes)
- Multiple layers of defense (escape, strip, validate)
- Clear error messages for debugging

Dependencies:
- bleach: HTML sanitization library
- html: Standard library HTML escaping
"""
import html
import re
from typing import Optional
from urllib.parse import urlparse
import bleach


# ===================================================================
# HTML Sanitization
# ===================================================================

def sanitize_html(text: str) -> str:
    """
    Basic HTML sanitization - escapes all HTML entities.

    Use this for plain text fields where NO HTML should be rendered.

    Args:
        text: Raw user input

    Returns:
        Text with HTML entities escaped

    Example:
        >>> sanitize_html("<script>alert('XSS')</script>")
        "&lt;script&gt;alert('XSS')&lt;/script&gt;"
    """
    return html.escape(text.strip())


# ===================================================================
# Markdown Sanitization
# ===================================================================

# Allowed HTML tags for markdown rendering
ALLOWED_MARKDOWN_TAGS = [
    # Text formatting
    'p', 'br', 'strong', 'em', 'u', 's', 'del', 'ins',
    'blockquote', 'code', 'pre', 'kbd', 'sup', 'sub',

    # Headings
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',

    # Lists
    'ul', 'ol', 'li',

    # Other
    'hr', 'a', 'img',

    # Tables
    'table', 'thead', 'tbody', 'tr', 'th', 'td',

    # Task lists
    'input',  # For [ ] checkboxes in markdown
]

# Allowed attributes for HTML tags
ALLOWED_MARKDOWN_ATTRIBUTES = {
    'a': ['href', 'title'],
    'img': ['src', 'alt', 'title', 'width', 'height'],
    'code': ['class'],  # For syntax highlighting (language-python, etc.)
    'pre': ['class'],
    'input': ['type', 'checked', 'disabled'],  # For task lists
}

# Allowed protocols for links (prevent javascript:, data:, etc.)
ALLOWED_PROTOCOLS = ['http', 'https', 'mailto']


def sanitize_markdown(text: str, allow_images: bool = True) -> str:
    """
    Sanitize markdown content to prevent XSS attacks.

    Uses bleach library to:
    - Allow safe HTML tags generated by markdown
    - Strip dangerous attributes (onclick, onerror, etc.)
    - Block javascript:, data: protocols in links
    - Escape everything else

    Args:
        text: Raw markdown/HTML content from user
        allow_images: Whether to allow <img> tags (default: True)

    Returns:
        Sanitized markdown content safe for rendering

    Example:
        >>> sanitize_markdown("[click me](javascript:alert('XSS'))")
        "<a>click me</a>"  # javascript: protocol stripped

        >>> sanitize_markdown("<img src=x onerror=alert('XSS')>")
        "<img src=\"x\">"  # onerror attribute stripped
    """
    stripped = text.strip()

    if not stripped:
        return ""

    # Optionally remove images
    tags = ALLOWED_MARKDOWN_TAGS.copy()
    if not allow_images:
        tags.remove('img')

    # Use bleach to sanitize
    sanitized = bleach.clean(
        stripped,
        tags=tags,
        attributes=ALLOWED_MARKDOWN_ATTRIBUTES,
        protocols=ALLOWED_PROTOCOLS,
        strip=True  # Strip disallowed tags instead of escaping
    )

    return sanitized


# ===================================================================
# Code Sanitization
# ===================================================================

def sanitize_code(code: str, max_length: int = 50000) -> str:
    """
    Sanitize code submissions.

    Code should NOT be HTML-escaped (needs to be executable),
    but we should enforce length limits to prevent DoS.

    Args:
        code: User-submitted code
        max_length: Maximum allowed length in characters

    Returns:
        Stripped code

    Raises:
        ValueError: If code exceeds max_length

    Example:
        >>> sanitize_code("print('Hello, World!')")
        "print('Hello, World!')"
    """
    stripped = code.strip()

    if len(stripped) > max_length:
        raise ValueError(f"Code exceeds maximum length of {max_length} characters")

    return stripped


# ===================================================================
# URL Validation
# ===================================================================

def validate_github_url(url: str) -> str:
    """
    Validate GitHub repository URL.

    Requirements:
    - Must use HTTPS protocol
    - Must be github.com domain
    - Must have format: https://github.com/{user}/{repo}

    Args:
        url: GitHub repository URL

    Returns:
        Validated URL

    Raises:
        ValueError: If URL is invalid

    Example:
        >>> validate_github_url("https://github.com/user/repo")
        "https://github.com/user/repo"

        >>> validate_github_url("http://github.com/user/repo")
        ValueError: GitHub URL must use HTTPS
    """
    # Parse URL
    try:
        parsed = urlparse(url)
    except Exception:
        raise ValueError("Invalid URL format")

    # Check protocol
    if parsed.scheme != 'https':
        raise ValueError("GitHub URL must use HTTPS protocol")

    # Check domain
    if parsed.netloc != 'github.com':
        raise ValueError("URL must be from github.com domain")

    # Check path format (should be /{user}/{repo} or /{user}/{repo}.git)
    path_parts = [p for p in parsed.path.split('/') if p]

    if len(path_parts) < 2:
        raise ValueError("GitHub URL must include user and repository (e.g., https://github.com/user/repo)")

    # Validate user and repo names (alphanumeric, hyphens, underscores, dots)
    user = path_parts[0]
    repo = path_parts[1].replace('.git', '')  # Remove .git suffix if present

    if not re.match(r'^[a-zA-Z0-9._-]+$', user):
        raise ValueError("Invalid GitHub username format")

    if not re.match(r'^[a-zA-Z0-9._-]+$', repo):
        raise ValueError("Invalid GitHub repository name format")

    # Reconstruct clean URL
    clean_url = f"https://github.com/{user}/{repo}"

    return clean_url


def validate_url(url: str, allowed_schemes: Optional[list[str]] = None) -> str:
    """
    Validate general URL.

    Args:
        url: URL to validate
        allowed_schemes: List of allowed schemes (default: ['http', 'https'])

    Returns:
        Validated URL

    Raises:
        ValueError: If URL is invalid

    Example:
        >>> validate_url("https://example.com")
        "https://example.com"

        >>> validate_url("javascript:alert('XSS')")
        ValueError: URL scheme not allowed
    """
    if allowed_schemes is None:
        allowed_schemes = ['http', 'https']

    # Parse URL
    try:
        parsed = urlparse(url)
    except Exception:
        raise ValueError("Invalid URL format")

    # Check scheme
    if parsed.scheme not in allowed_schemes:
        raise ValueError(f"URL scheme not allowed. Allowed schemes: {', '.join(allowed_schemes)}")

    # Basic validation - must have scheme and netloc
    if not parsed.scheme or not parsed.netloc:
        raise ValueError("URL must have valid scheme and domain")

    return url


# ===================================================================
# Text Validation Utilities
# ===================================================================

def validate_length(text: str, min_length: int = 0, max_length: int = 10000, field_name: str = "Field") -> str:
    """
    Validate text length after stripping whitespace.

    Args:
        text: Text to validate
        min_length: Minimum length (default: 0)
        max_length: Maximum length (default: 10000)
        field_name: Name of field for error messages

    Returns:
        Stripped text

    Raises:
        ValueError: If text length is invalid

    Example:
        >>> validate_length("  test  ", min_length=1, max_length=100)
        "test"
    """
    stripped = text.strip()

    if len(stripped) < min_length:
        raise ValueError(f"{field_name} must be at least {min_length} characters (after removing whitespace)")

    if len(stripped) > max_length:
        raise ValueError(f"{field_name} must be at most {max_length} characters")

    return stripped


def contains_zero_width_only(text: str) -> bool:
    """
    Check if text contains only zero-width characters.

    Zero-width characters:
    - \\u200b: Zero-width space
    - \\u200c: Zero-width non-joiner
    - \\u200d: Zero-width joiner
    - \\ufeff: Zero-width no-break space (BOM)

    Args:
        text: Text to check

    Returns:
        True if text contains only zero-width characters

    Example:
        >>> contains_zero_width_only("\\u200b\\u200b\\u200b")
        True

        >>> contains_zero_width_only("Hello\\u200bWorld")
        False
    """
    # Remove all zero-width characters
    cleaned = re.sub(r'[\u200b\u200c\u200d\ufeff]', '', text)

    # If nothing left, it was all zero-width
    return len(cleaned.strip()) == 0


# ===================================================================
# SQL Injection Prevention
# ===================================================================

def sanitize_sql_like_pattern(pattern: str) -> str:
    """
    Sanitize user input for SQL LIKE patterns.

    Escapes special LIKE characters: %, _, [, ], ^

    Note: This is NOT a replacement for parameterized queries.
    Always use parameterized queries for SQL. This is only for
    sanitizing LIKE patterns that will be used in parameterized queries.

    Args:
        pattern: User search pattern

    Returns:
        Escaped pattern

    Example:
        >>> sanitize_sql_like_pattern("test_pattern")
        "test\\_pattern"
    """
    # Escape LIKE special characters
    pattern = pattern.replace('\\', '\\\\')  # Escape backslash first
    pattern = pattern.replace('%', '\\%')
    pattern = pattern.replace('_', '\\_')
    pattern = pattern.replace('[', '\\[')
    pattern = pattern.replace(']', '\\]')
    pattern = pattern.replace('^', '\\^')

    return pattern
